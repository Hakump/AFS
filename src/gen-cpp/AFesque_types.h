/**
 * Autogenerated by Thrift Compiler (0.15.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef AFesque_TYPES_H
#define AFesque_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <functional>
#include <memory>




class ServerException;

class FStatShort;

class FStat;

class tDirent;

typedef struct _ServerException__isset {
  _ServerException__isset() : err_no(false) {}
  bool err_no :1;
} _ServerException__isset;

/**
 * *****
 *  Author: C. Todd Hayes-Birchler
 *  Date: 2/19/22
 *  CS 739, UW Madison, CS Department
 * 
 *  Thrift i32erface for stub generation
 * ******
 */
class ServerException : public ::apache::thrift::TException {
 public:

  ServerException(const ServerException&) noexcept;
  ServerException& operator=(const ServerException&) noexcept;
  ServerException() noexcept
                  : err_no(0) {
  }

  virtual ~ServerException() noexcept;
  int32_t err_no;

  _ServerException__isset __isset;

  void __set_err_no(const int32_t val);

  bool operator == (const ServerException & rhs) const
  {
    if (!(err_no == rhs.err_no))
      return false;
    return true;
  }
  bool operator != (const ServerException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ServerException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const noexcept override;
};

void swap(ServerException &a, ServerException &b);

std::ostream& operator<<(std::ostream& out, const ServerException& obj);

typedef struct _FStatShort__isset {
  _FStatShort__isset() : st_mtimes_tv_sec(false), st_mtimes_tv_nsec(false), st_atimes_tv_sec(false), st_atimes_tv_nsec(false), is_compressed(false), num_chunks(false) {}
  bool st_mtimes_tv_sec :1;
  bool st_mtimes_tv_nsec :1;
  bool st_atimes_tv_sec :1;
  bool st_atimes_tv_nsec :1;
  bool is_compressed :1;
  bool num_chunks :1;
} _FStatShort__isset;

class FStatShort : public virtual ::apache::thrift::TBase {
 public:

  FStatShort(const FStatShort&) noexcept;
  FStatShort& operator=(const FStatShort&) noexcept;
  FStatShort() noexcept
             : st_mtimes_tv_sec(0),
               st_mtimes_tv_nsec(0),
               st_atimes_tv_sec(0),
               st_atimes_tv_nsec(0),
               is_compressed(0),
               num_chunks(0) {
  }

  virtual ~FStatShort() noexcept;
  int64_t st_mtimes_tv_sec;
  int64_t st_mtimes_tv_nsec;
  int64_t st_atimes_tv_sec;
  int64_t st_atimes_tv_nsec;
  bool is_compressed;
  int32_t num_chunks;

  _FStatShort__isset __isset;

  void __set_st_mtimes_tv_sec(const int64_t val);

  void __set_st_mtimes_tv_nsec(const int64_t val);

  void __set_st_atimes_tv_sec(const int64_t val);

  void __set_st_atimes_tv_nsec(const int64_t val);

  void __set_is_compressed(const bool val);

  void __set_num_chunks(const int32_t val);

  bool operator == (const FStatShort & rhs) const
  {
    if (!(st_mtimes_tv_sec == rhs.st_mtimes_tv_sec))
      return false;
    if (!(st_mtimes_tv_nsec == rhs.st_mtimes_tv_nsec))
      return false;
    if (!(st_atimes_tv_sec == rhs.st_atimes_tv_sec))
      return false;
    if (!(st_atimes_tv_nsec == rhs.st_atimes_tv_nsec))
      return false;
    if (!(is_compressed == rhs.is_compressed))
      return false;
    if (!(num_chunks == rhs.num_chunks))
      return false;
    return true;
  }
  bool operator != (const FStatShort &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FStatShort & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(FStatShort &a, FStatShort &b);

std::ostream& operator<<(std::ostream& out, const FStatShort& obj);

typedef struct _FStat__isset {
  _FStat__isset() : st_dev(false), st_ino(false), st_mode(false), st_nlink(false), st_gid(false), st_rdev(false), st_size(false), st_blksize(false), st_blocks(false), st_mtimes_tv_sec(false), st_mtimes_tv_nsec(false), st_atimes_tv_sec(false), st_atimes_tv_nsec(false), st_ctimes_tv_sec(false), st_ctimes_tv_nsec(false) {}
  bool st_dev :1;
  bool st_ino :1;
  bool st_mode :1;
  bool st_nlink :1;
  bool st_gid :1;
  bool st_rdev :1;
  bool st_size :1;
  bool st_blksize :1;
  bool st_blocks :1;
  bool st_mtimes_tv_sec :1;
  bool st_mtimes_tv_nsec :1;
  bool st_atimes_tv_sec :1;
  bool st_atimes_tv_nsec :1;
  bool st_ctimes_tv_sec :1;
  bool st_ctimes_tv_nsec :1;
} _FStat__isset;

class FStat : public virtual ::apache::thrift::TBase {
 public:

  FStat(const FStat&) noexcept;
  FStat& operator=(const FStat&) noexcept;
  FStat() noexcept
        : st_dev(0),
          st_ino(0),
          st_mode(0),
          st_nlink(0),
          st_gid(0),
          st_rdev(0),
          st_size(0),
          st_blksize(0),
          st_blocks(0),
          st_mtimes_tv_sec(0),
          st_mtimes_tv_nsec(0),
          st_atimes_tv_sec(0),
          st_atimes_tv_nsec(0),
          st_ctimes_tv_sec(0),
          st_ctimes_tv_nsec(0) {
  }

  virtual ~FStat() noexcept;
  int64_t st_dev;
  int64_t st_ino;
  int32_t st_mode;
  int64_t st_nlink;
  int32_t st_gid;
  int64_t st_rdev;
  int64_t st_size;
  int64_t st_blksize;
  int64_t st_blocks;
  int64_t st_mtimes_tv_sec;
  int64_t st_mtimes_tv_nsec;
  int64_t st_atimes_tv_sec;
  int64_t st_atimes_tv_nsec;
  int64_t st_ctimes_tv_sec;
  int64_t st_ctimes_tv_nsec;

  _FStat__isset __isset;

  void __set_st_dev(const int64_t val);

  void __set_st_ino(const int64_t val);

  void __set_st_mode(const int32_t val);

  void __set_st_nlink(const int64_t val);

  void __set_st_gid(const int32_t val);

  void __set_st_rdev(const int64_t val);

  void __set_st_size(const int64_t val);

  void __set_st_blksize(const int64_t val);

  void __set_st_blocks(const int64_t val);

  void __set_st_mtimes_tv_sec(const int64_t val);

  void __set_st_mtimes_tv_nsec(const int64_t val);

  void __set_st_atimes_tv_sec(const int64_t val);

  void __set_st_atimes_tv_nsec(const int64_t val);

  void __set_st_ctimes_tv_sec(const int64_t val);

  void __set_st_ctimes_tv_nsec(const int64_t val);

  bool operator == (const FStat & rhs) const
  {
    if (!(st_dev == rhs.st_dev))
      return false;
    if (!(st_ino == rhs.st_ino))
      return false;
    if (!(st_mode == rhs.st_mode))
      return false;
    if (!(st_nlink == rhs.st_nlink))
      return false;
    if (!(st_gid == rhs.st_gid))
      return false;
    if (!(st_rdev == rhs.st_rdev))
      return false;
    if (!(st_size == rhs.st_size))
      return false;
    if (!(st_blksize == rhs.st_blksize))
      return false;
    if (!(st_blocks == rhs.st_blocks))
      return false;
    if (!(st_mtimes_tv_sec == rhs.st_mtimes_tv_sec))
      return false;
    if (!(st_mtimes_tv_nsec == rhs.st_mtimes_tv_nsec))
      return false;
    if (!(st_atimes_tv_sec == rhs.st_atimes_tv_sec))
      return false;
    if (!(st_atimes_tv_nsec == rhs.st_atimes_tv_nsec))
      return false;
    if (!(st_ctimes_tv_sec == rhs.st_ctimes_tv_sec))
      return false;
    if (!(st_ctimes_tv_nsec == rhs.st_ctimes_tv_nsec))
      return false;
    return true;
  }
  bool operator != (const FStat &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FStat & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(FStat &a, FStat &b);

std::ostream& operator<<(std::ostream& out, const FStat& obj);

typedef struct _tDirent__isset {
  _tDirent__isset() : d_ino(false), d_off(false), d_reclen(false), d_type(false), d_name(false) {}
  bool d_ino :1;
  bool d_off :1;
  bool d_reclen :1;
  bool d_type :1;
  bool d_name :1;
} _tDirent__isset;

class tDirent : public virtual ::apache::thrift::TBase {
 public:

  tDirent(const tDirent&);
  tDirent& operator=(const tDirent&);
  tDirent() noexcept
          : d_ino(0),
            d_off(0),
            d_reclen(0),
            d_type(0),
            d_name() {
  }

  virtual ~tDirent() noexcept;
  int64_t d_ino;
  int64_t d_off;
  int16_t d_reclen;
  int8_t d_type;
  std::string d_name;

  _tDirent__isset __isset;

  void __set_d_ino(const int64_t val);

  void __set_d_off(const int64_t val);

  void __set_d_reclen(const int16_t val);

  void __set_d_type(const int8_t val);

  void __set_d_name(const std::string& val);

  bool operator == (const tDirent & rhs) const
  {
    if (!(d_ino == rhs.d_ino))
      return false;
    if (!(d_off == rhs.d_off))
      return false;
    if (!(d_reclen == rhs.d_reclen))
      return false;
    if (!(d_type == rhs.d_type))
      return false;
    if (!(d_name == rhs.d_name))
      return false;
    return true;
  }
  bool operator != (const tDirent &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const tDirent & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(tDirent &a, tDirent &b);

std::ostream& operator<<(std::ostream& out, const tDirent& obj);



#endif
